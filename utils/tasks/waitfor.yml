---
- name: (UTILS-WAITFOR) assert
  assert:
    that: 
      - wait_host_ip is defined and wait_host_ip is not none
      - wait_port is defined and wait_port | int > 0
      - wait_proto is defined and wait_proto | lower in ['ssh','psrp']
    fail_msg: "Need to specify wait_host_ip (ip address), wait_port (number > 0) and wait_proto (ssh, psrp), wait_host_name is optional"
    success_msg: "{{ wait_host }} {{ wait_port }} {{ wait_proto }} {{ ponder | default(false) }} {{ wait_host_name | default('no wait_host_name') }}"
    
- name: (UTILS-WAITFOR) Wait until ready
  block:
    - set_fact:
        ponder: "{{ ponder | default(false) }}"
      delegate_to: localhost

    - name: (UTILS-WAITFOR) Set the retry count for connection
      set_fact:
        retry_count: "{{ 1 if retry_count is undefined else retry_count|int + 1 }}"
      delegate_to: localhost

    - name: (UTILS-WAITFOR) Wait for admin port to be available (after 60 seconds)
      wait_for:
        port: "{{ wait_port }}"
        host: "{{ wait_host_ip }}"
        delay: 60
        timeout: 900
      delegate_to: localhost

    - name: (UTILS-WAITFOR) do a setup on the target host
      setup:
      ignore_unreachable: true
      register: mysetup
      when:  ponder
      delegate_to: "{{ wait_host_name | default(omit) }}"

    - name: (UTILS-WAITFOR) force error if setup failed on the target host
      command: /bin/false
      delegate_to: localhost
      when:
        - ponder
        - mysetup.unreachable is defined

    - name: (UTILS-WAITFOR, common Linux) Ponder
      block:
        - name: (UTILS-WAITFOR, redhat) Check for lock files on Red Hat-based systems
          find:
            paths:
              - /var/run/yum.pid
              - /var/run/dnf.pid
              - /var/lib/yum/yum.pid
              - /var/lib/dnf/dnf.pid
            file_type: file
          delegate_to: "{{ wait_host_name | default(omit) }}"
          when: ansible_os_family | lower == 'redhat'
          register: redhat_lock_files

        - name: (UTILS-WAITFOR, ubuntu) Check for lock files on Ubuntu-based systems
          find:
            paths:
              - /var/lib/dpkg/lock
              - /var/lib/dpkg/lock-frontend
              - /var/cache/apt/archives/lock
              - /var/lib/apt/lists/lock
            file_type: file
          delegate_to: "{{ wait_host_name | default(omit) }}"
          when: ansible_os_family | lower == 'debian'
          register: ubuntu_lock_files

        - name: (UTILS-WAITFOR, sles) Check for lock files on SLES-based systems
          find:
            paths:
              - /var/run/zypp.pid
              - /var/cache/zypp/zypp.lock
            file_type: file
          delegate_to: "{{ wait_host_name | default(omit) }}"
          when: ansible_os_family | lower == 'suse'
          register: sles_lock_files

        - name: (UTILS-WAITFOR, redhat) Report Red Hat lock files
          debug:
            msg: "Red Hat lock files found: {{ redhat_lock_files.files | map(attribute='path') | list }}"
          when: ansible_os_family | lower == 'redhat'
          failed_when: redhat_lock_files.files | map(attribute='path') | list | length  > 0

        - name: (UTILS-WAITFOR, ubuntu) Report Ubuntu lock files
          debug:
            msg: "Ubuntu lock files found: {{ ubuntu_lock_files.files | map(attribute='path') | list }}"
          when: ansible_os_family | lower == 'debian'
          failed_when: ubuntu_lock_files.files | map(attribute='path') | list | length  > 0

        - name: (UTILS-WAITFOR, sles) Report SLES lock files
          debug:
            msg: "SLES lock files found: {{ sles_lock_files.files | map(attribute='path') | list }}"
          when: ansible_os_family | lower == 'suse'
          failed_when: sles_lock_files.files | map(attribute='path') | list | length > 0

      when:  
      - ponder
      - wait_proto | lower == "ssh" 
    
    - name: (UTILS-WAITFOR, Windows) Ponder
      block:
      - name: (UTILS-WAITFOR, Windows) Ponder 
        win_shell: |
          function ExitWithCode($exitCode) {
              $host.SetShouldExit($exitCode)
              Exit
          }
          Add-Type @'
            using System;
            using System.Runtime.InteropServices;

            public static class Windows
            {
                [DllImport("kernel32", SetLastError=true)]
                public static extern UInt64 GetTickCount64();

                public static TimeSpan GetUptime()
                {
                    return TimeSpan.FromMilliseconds(GetTickCount64());
                }
            }
          '@

          function Wait-Condition {
              param(
                [scriptblock]$Condition,
                [int]$DebounceSeconds=15
              )
              process {
                  $begin = [Windows]::GetUptime()
                  do {
                      Start-Sleep -Seconds 1
                      try {
                        $result = &$Condition
                      } catch {
                        $result = $false
                      }
                      if (-not $result) {
                          $begin = [Windows]::GetUptime()
                          continue
                      }
                  } while ((([Windows]::GetUptime()) - $begin).TotalSeconds -lt $DebounceSeconds)
              }
          }
          Write-Output 'Waiting for the Windows Modules Installer to exit...'
          Wait-Condition {(Get-Process -ErrorAction SilentlyContinue TiWorker | Measure-Object).Count -eq 0}
          ExitWithCode 0
        ignore_unreachable: true
        delegate_to: "{{ wait_host_name | default(omit) }}"
        register: mysetup

      - name: (UTILS-WAITFOR) do a setup again after pondering
        setup:
        ignore_unreachable: true
        register: mysetup
        delegate_to: "{{ wait_host_name | default(omit) }}"
        when: ponder

      - name: (UTILS-WAITFOR) force failure if setup failed
        command: /bin/false
        delegate_to: localhost
        when: 
        - ponder
        - mysetup.unreachable is defined
      when: 
        - ponder
        - wait_proto == "psrp" 


  rescue:

    - debug:
        msg: "fail count = {{ retry_count }}"

    - fail:
        msg: Ended after 15 tries
      when: retry_count|int >=  15


    - name: (UTILS-WAITFOR) hold on for 2 minutes to give the target system a chance to sort itself out.
      wait_for:
        timeout: 120
      delegate_to: localhost


    - debug:
        msg: "Failed to connect - Retrying..."


    - include_tasks: "waitfor.yml"